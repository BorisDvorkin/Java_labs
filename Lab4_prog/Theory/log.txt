> Вложенный класс - это класс, который определён внутри другого класса.
Нужен, чтобы обслуживать окружающий его класс. Может также использоваться для лучшей инкапсуляции.

Вложенный класс имеет доступ к членам своего внешнего класса, в том числе и к закрытым членам. 
Однако, внешний класс не имеет доступа к членам вложенного класса

Пример:
class OuterClass {
	class NestedClass1 {
		class NestedClass2 {
			...
		}
	}
}


> Вложенный статический класс - это вложенный класс с модификатором static.
Нужен в том случае, когда связь между объектом вложенного класса и объектом внешнего класса не нужна.

Статические внутренние классы декларируются внутри основного класса и обозначаются ключевым словом static. 
Они не имеют доступа к членам внешнего класса за исключением статических.

Статический внутренний класс может содержать статические поля, методы и классы, 
в отличие от других типов внутренних классов

Пример:
class OuterClass {
	static class NestedClass1 {
		...
	}
}


> Локальный класс - это вложенный класс, который объявлен внутри какого-то блока
кода(статический блок, цикл for, тело if, конструктор, метод и так далее) другого
класса

Локальный класс наделён особенностями внутренних классов, но имеет отличительные черты, а именно:
1)он имеет доступ только к финальным полям и аргументам обрамляющего метода, а также ко всем полям обрамляющего класса, в том числе приватным и статическим;
2)локальный класс виден и может создаваться только в блоке, в котором описан;

3)у локального класса не ставиться модификатор доступа;
4)не может иметь статических полей, методов, классов (за исключением финальных);
5)локальный класс, объявленный в статическом блоке может обращаться только к статическим полям внешнего класса.

Пример:
affect(int affect, CosmicObject surface) {      // это метод
    class GiveSpecialAbility {         // это локальный класс внутри метода affect
        private int affect;
        private CosmicObject surface;

        public GiveSpecialAbility(int affect, CosmicObject surface) {
            this.affect = affect;
            this.surface = surface;
        }

        public String findOutSpecialAbility() {
            if (surface.getName() == "Moon" && affect > 0) {
                return surface.getName() + " Обладает способностью светиться с силой " + affect.toInt();
            }
            return "Космические лучи действуют на всех людей на " + surface.getName() + " с силой " + affect.toInt();
        }
    }
    GiveSpecialAbility ability = new GiveSpecialAbility(affect, surface);
    return ability.findOutSpecialAbility();
}


> Анонимный класс - это локальный класс, который не имеет имени.

Он может:
- extends другой класс(тогда анонимный класс - это подкласс другого класса)
или
- implements интерфейс(тогда анонимный класс реализует этот интерфейс и расширяет Object)

!! Может реализовать ТОЛЬКО один интерфейс

Для анонимных классов, так же как и для локальных, компилятор передает в конструктор скрытую ссылку .this на окружающий класс.
Поэтому к объекту окружающего класса можно обращаться так же, как и в локальном классе – через имя_венешнего_класса.this.

Анонимный класс не может определять статические поля, методы или классы, кроме констант static final. Интерфейс не может быть объявлен анонимно, потому что нет способа реализовать интерфейс без имени. Так же как и локальные классы, анонимные классы не могут быть public, private, protected или static.

В анонимном классе вы не можете объявить статические инициализационные блоки.

В анонимном классе вы не можете объявить интерфейс.

Поскольку у анонимного класса нет имени, то невозможно определить конструктор анонимного класса. 
Если вашему классу нужен конструктор, вы должны задействовать локальный класс
Т.к. он полноценный внутренний класс, то есть доступ к переменным внешнего класса, в том числе статическим и приватным.

Видны только в пределах метода, внутри которого определены

!! Анонимный класс не может содержать статические переменные и методы(Вообще, с Java16 все внутренние классы могут.)

Объявление такого класса выполняется одновременно с созданием его объекта с помощью new.
Анонимный класс не может иметь конструкторов(т.к. имени конструктора совпадать не с чем, класс ведь безымянный)
анонимные классы допускаю вложенность друг в друга, но это сильно запутает код

Oracle: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования».

Пример:
public static diskShine() { // это метод, внутри которого делаю анонимный класс
    Shine disk = new Shine() {  // это анонимный класс
        @ Override
        public void shine() {
            return sout("светящийся диск");
        }
    };
    disk.shine()
}

Как это работает на самом деле:
1) создаётся БЕЗЫМЯННЫЙ класс, реализующий интерфейс Shine
2) Компилятор требует реализовать все методы интерфейсы Shine
3) создаётся объект данного безымянного класса с названием disk
!! В конце ставим ; потому что мы как бы создаём объект. Interface obj = new Interface(){};
посредством {} мы объявили класс, а с помощью (); создали объект, поэтому и надо поставить ;







Вопросы:
- что такое effectively final?
- отличие лямбда-выражения от анонимного класса при реализации функционального интерфейса
- как отловить несколько исключений и по-разному их обработать
вопрос рофляный и я знал на него ответ, но почему-то вам не сказал, ожидая чего-то более сложного
try{
} catch() {
} catch() {
} catch() {
}

Ответил:
- иерархию throwable
- checked/unchecked
- как сделать так чтобы finally не выполнился? -> system.exit(0)
- что такое анонимный класс? зачем он нужен?
- в каком порядке throws исключения?





1) Разновидности вложенных классов java (Статические вложенные, внутренние, локальные, анонимные)
2) Exceptions (checked exception, error exception, runtime exception) - деление на checked/unchecked
3) reflection API
4) класс Class
**
- сборщик мусора, в чём различие 4 типов сборщика мусора
- отличие string builder string buffer
- как устроен arrayList как происходит удаление вставка элемента
- виды исключений, таблица
- try catch finally
- что будет если в try написать system.exit(0) - сработает ли после этого finally? да, сработает.